** 3.5数组
*** 3.5.1 定义和初始化内置数组
    不能将数组的内容拷贝给其他数组
*** 3.5.2 访问数组元素
    使用数组下标时候定义为size_t类型
*** 3.5.3指针和数组
    使用数组类型的对象其实是使用一个指向该数组首元素的指针。
    内置的（例如array)运算符所用的索引值不是无符号类型，这一点与vector和string不一样
*** decltype 返回类型是该类型的一个实例成员
    int ia[]={0,1,2,3,4};
    decltype(ia) ia3;//ia3是由5个整数构成的数组
*** 3.5.4 C风格字符串
*** 3.5.5 与旧代码的接口
    现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量
    使用string,避免使用C风格的字符串。
** 3.6多维数组
   严格点说，C++语言中没有多维数组，所谓的多维数组，就是数组的数组，谨记这一点
   去理解多维数组。
    
*     第4章   表达式
** 4.1 基础
*** 基础概念
    左值和右值：当一个对象被用作右值的时候，使用的是它的内容（值）。
               ................左....................身份（在内存中的位置）。
*     第5章   语句
*     第6章   函数
** 6.1 函数的基础
   编写函数：
   调用函数：调用函数完成两项工作：一是用实参初始化函数队形的形参，二是将控制权转移给被调
用函数，此时，主调函数（calling function)的执行被暂时中断，被调函数(called function)
开始执行。
   形参和实参：数目类型匹配
   函数的形参列表：
   函数返回类型：void不返回任何值，返回类型不能是数组或函数类型，但可以是指向其的
指针。

*** 6.1.1 局部对象
    理解名字由作用域，对象有生命周期。
    自动对象：只存在于块执行期间的对象称为自动对象。
    局部静态对象：局部变量的生命周期贯穿函数调用及之后的时间。
定义方式 static .
*** 6.1.2 函数声明
*** 6.1.3 分离式编译
** 6.2 参数传递
*** 6.2.1 传值参数
    当初始化一个非引用类型的变量时，初始值被拷贝给变量，此时对变量的改动不会
影响初始值。
    指针形参：指针的行为和其他非引用类型一样，当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后，
两个指针是不同的指针，因为指针使我们可以简介的访问它所指的对象，所有通过指针可以修改它所指的对象哪个的值。
  例：void reset(int *ip){
         *ip=0;           //改变了指针所指对象的值
	 ip=0;            //只改变了ip的局部拷贝，实参未被改变
	}
      int main(){
        int i=42;          
	reset(&i);         //改变了i的值而非i的地址
	cout<<"i="<<i<<endl;
	}
	建议使用引用类型的形参替代指针。
*** 6.2.2 传引用参数
  引用行擦绑定初始化它的对象。对形参的操作即是对实参的操作。
  使用引用避免拷贝：拷贝比较低效，甚至有些类类型不支持拷贝
                    所以尽量使用引用访问该类型的对象。
  如果函数无须改变引用形参的值，将其声明为常量引用。
  使用引用形参返回额外信息：
*** 6.2.3 const形参和实参
    和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const,
换句话所，形参的顶层const被忽略掉了，当形参由顶层const时，传给他常量对象
或者非常量对象都是可以的。
    指针或引用形参与const
    尽量使用常量引用
*** 6.2.4 数组形参
    用数组作为形参，会自动转换成指向数组首元素的指针，数组的大小对函数的调用没有影响 
    管理指针形参有3种常用的技术：
    1 使用标记指定数组长度           针对C风格字符串
    2 使用标准库范围                 标准库技术的启发
    3 显示传递一个表示数组大小的形参  专门定义个表示数组大小的形参
    数组形参和const
    数组的引用形参 数组的维度一定要匹配
    传递多维数组
*** 6.2.5 main:处理命令行选项
    int main(argv,char *argv[]).....当使用argv中的实参时，一定要记得可选的实参
从argv[1]开始，argv[0]保存程序的名字，而非用户输入。
     
*** 6.2.6 含有可变形参的函数
    initializer_list:实参的数量未知，实参类型相同。initializer_list是一种标准库类型，
用于表示某种特定类型的值的数组。initializer_list和vector一样也是一种模板类型，
和vector不一样的是，initializer_list对象中的元素永远是常量，我们无法改变initializer_list
对象中的元素的值。
    实参的类型不同，建立个可变参数模板。
    省略符形参：出现在形参列表的最后一个位置，省略符形参所对应的实参无须类型检查。
** 6.3 返回类型和return语句 
*** 6.3.1 无返回值函数
用在void函数中
*** 6.3.2 有返回值函数
    值是如何被返回的
    不要返回局部对象的引用或指针。
    当函数结束时临时对象占用的空间也就随之释放掉了，所以两条return语句都
    指向了一再可以的内存空间。
返回类类型的函数和调用运算符
引用返回左值：
调用一个返回引用的函数得到左值，其他返回类型得到右值。
列表初始化返回值：
主函数main的返回值




 

    

*** 6.3.3 返回数组指针
     数组不能被拷贝，所以函数不能返回数组，但函数可以返回数组的指针或引用，语法上
麻烦，由些方法可以简化这一任务：使用类型别名。
     typedef int arrT[10]        //表示该类型是含有10个整数的数组
     using arrT=int[10]          //等价声明
     arrT *func(int i);          //func返回一个指向含有10个整数的数组的指针
     声明一个返回数组指针的函数
     使用尾置返回类型：
auto func(int i)->int(*)[10];//func接受一个int类型的实参，返回一个
指针，该指针指向了一个含有10个整数的数组。
使用decltype
有一种情况，我们知道函数返回的指针指向哪个数组，就可以使用decltype
    int odd[]={1,2,3,4,5};
    decltype(odd) *arrPtr(int i)    //返回一个指针，该指针指向含有5个整数的数组
** 6.4  函数重载
        同一作用域内的几个函数名字相同但形参列表不同，称为函数重载
        函数名字仅仅让编译器知道它调用的是哪个函数，而重载可以在一定程度上减轻程序员
起名字、记名字的负担。
        定义重载函数：
	判断两个形参的类型是否相异
	重载和const形参
	const_cast和重载
	调用重载的函数
重载函数的三种可能：
       1  编译器找到最佳匹配，并生成代码
       2  找不到，发生匹配错误
       3  找到不只一个，此时也发生错误，称为二义性调用。
*** 6.4.1 重载与作用域
** 6.5特殊用途语言特性
*** 6.5.1默认实参
*** 6.5.2内联函数
    内联函数可避免函数调用的开销
*** 6.5.3constexpr函数
** 6.7 函数指针
函数指针指向的是函数而非对象。
想要声明一个可以指向该函数的指针，只需要用指针替换函数名即可。
   bool lengthcompare(const string &,const string &)
   bool (*pf)(const string &,const string &)
我们从声明的名字开始观察，pf前面有个*，因此pf是指针，右侧是形参列表，
表示pf指向的是函数，再观察左侧，发现函数的返回类型是布尔值。因此，pf
就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是
bool类型
note:*pf两端的括号必不可少，如果不写这对括号，则pf是一个返回值为
bool指针的函数。
   bool *pf(const string &,const string &)
   //声明一个名为pf的函数，该函数返回bool*
使用函数指针
当我们把函数名作为一个值使用时，该函数自动的转换成指针.
    pf=lengthcompare;   //pf指向lengthcompare的函数
    pf=&lengthcompare;  //等价的赋值语句
此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针
   bool b1=pf("hello","gooble");   //调用lengthcompareh函数
   bool b2=(*pf)("hello","gooble")  //一个等价调用
   bool b3=lengthcompare("hello","gooble")  //另一个等价调用
重载函数的指针
函数指针形参



*     第7章    类
类的基本思想是数据抽象和封装
数据抽象是一种依赖于接口和实现分离的编程技术，类的接口包括由用户所能执行
的操作，类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的
各种私有函数。
封装实现类类的接口和实现的分离。封装后的类隐藏了它实现的细节，也就是说，
类的用户只能使用接口而无法访问实现部分。
类要想实现数据抽象和封装，需要首先定义一个抽象数据类型。
** 7.1 定义抽象数据类型
*** 7.1.1 设计Sales_data类
*** 7.1.1 设计Sales_data类
    ..一个isbn成员函数
    ..一个combine成员函数
    ..一个名为add的函数
    ..一个read函数
    ..一个print函数
    使用改进的Sales_data类
*** 7.1.2 定义改进的Sales_data类
tring isbn()const{return bookno;}
和其他函数一样，成员函数体也是一个块，在上列中只有一条return语句，用于
返回Sales_date对象的bookNo数据成员。它是如何获得bookNo所依赖的对象的呢？
****    引入 this
    仔细观察isbn成员函数的调用：total.isbn()
    ...使用点运算符，访问total对象的isbn成员，然后调用它
当我们调用成员函数时，实际上是替某个对象在调用它。
如果isbn指向Sales_data成员(例如bookNo),则它隐士的指向调用该函数的
对象的成员，所以，isbn返回bookNo时，它实际上隐士的返回total.bookNo.
     成员函数通过一个名为this的额外的隐士参数来访问调用它的那个对象，
当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如：
     total.isbn()
     则编译器负责把total的地址传递给isbn的隐士形参this,可以等价的人为
编译器将该调用重写成了如下的形式：
     //伪代码，用于说明调用成员的实际过程
     Sale_data::isbn(&total)
     其中，调用Sale_data的isbn成员时传入了total的地址。
     在成员函数的内部，我们可以直接使用调用该函数的对象的成员，因为
this所指的正是这个对象，任何对类成员的直接访问都被看作this的隐士引用，
也就是说，当isbn使用bookNo时，它隐士的使用this指向的成员，就想this->bookNo一样。
     关于this,this形参是隐士定义的。实际上，任何自定义名为this的参数
或变量的行为都是非法的。但我们可以在成员函数体内部使用this，因此我们
还能把isbn定义成如下形式：
      string isbn() const{return this->bookNo;}
      因为this的目的总是指向“这个”对象，所以this是一个常量指针，我们允许改变this中保存的地址

          
****    引入 const成员函数
	isbn函数的另一个关键之处是紧随参数列表之后的const关键字
这里，const的作用是修改隐士的this指针的类型。
默认情况下，this的类型是指向类类型非常量版本的常量指针。在Sales_data
成员函数中，this的类型是Sales_data *const.尽管this是隐士的，但它仍然需要
遵循初始化规则，意味着（默认情况下）我们不能把this绑定到一个常量对象上。
这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。
        如果isbn是一个普通函数而且this是一个普通指针参数，则我们因该
把this声明成const Sales_data *const.毕竟，在isbn的函数体内不会改变this所指的对象，
所以把this设置为指向常量的指针有助于提高函数的灵活性。
         然而，this是隐士的并且不会出现在参数列表中，所以在哪儿将this
声明成指向常量的指针就称为我们必须面对的问题，C++语言的做法是允许把const
关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this
是一个指向常量的指针，像这样使用const的成眼函数被称作常量成员函数。
         可以把isbn的函数体想象成如下的形式：
	 //为代码，说明隐士的this指针是如何使用的
	 //下面的代码是非法的：因为我们不能显示的定义自己的this指针
	 //谨记此处的this是一个指向常量的指针，因为isbn是一个常量成员
	 string Sales_data::isbn(const Sales_data *const this)
	 {return this->bookNo;}
	 因为this是指向常量的指针，所以常量成员函数不能改变调用他的对象的内容。在
上例中，isbn可以读取调用它的对象数据成员，但是不能写入新值。
note: 常量对象，以及常量对象的引用或指针之恩嗯调用常量成员
****    类作用域和成员函数
	即使bookNo定义在isbn之后，isbn也还是能够使用bookNo,因为编译器分两步处理类：
首先编译成员的声明，然后才轮到成员函数体（如果有的话），因此，成员函数体可以
随意使用类中的其他成员而无须在意这些成员出现的次序。

****    在类的外部定义成员函数
	像其他函数一样，当我们在类的外部定义成员函数时，成员函数的定义必须与
它的声明匹配，同时，类外部定义的成员的名字必须包含它所属的类名：
        double Sales_data::avg_price(){
	      if(units_sold)
	          return revenue/units_sold;
		  else
         	  return 0;
	}	    
	作用域运算符来说明如下事实：我们定义了一个名为avg_price的函数，
并且该函数声明在类Sales_data的作用域内。一旦编译器看到这个函数名，就能
理解剩余的代码是位于类的作用域内的。因此，当avg_price可以使用revenue
和units_sold的属于Sales_data的数据成员。
****    定义一个返回this对象的函数
	函数combine的设计初衷类似于复合复制运算符+=，调用该函数的对象，
代表的是赋值运算符左侧的运算对象，右侧运算对象则通过显示的实参被传入函数。
   Sales_date & Sales_date::comebine(const Sales_date &rhs)
   {
       units_sold+=rhs.units_sold;
       revenue+=rhs.revenue;
       retrun *this;
   }
        当我们的交易处理程序调用如下函数时，
	  total.combine(trans);     //更新变量total当前的值
total的地址被绑定到隐士的this参数上，而rhs绑定到了trans上，因此
当combine执行下面语句：
        units_sold+=rhs.units_sold;  //把rhs的成员添加到this对象的成员中
效果等同于total.units_sold+=trans.units_sold;
        该函数一个值得关注的部分是它返回类型和返回语句，一般来说，当我们定义的函数
类似与某个内置运算符时，应该令该函数的行为尽量模仿这个运算符。内置赋值运算符把
它的左侧运算对象当成左值返回，因此为了与它保持一致，combine函数必须返回引用类型。
因为此时的左侧运算对象是一个Sales_data的对象。所以返回类型应该是Sales_data&.
        如前所述，我们无须使用隐士的this指针访问函数调用者的某个具体成员，而是需要
把调用函数的对象当成一个整体来访问：
        return *this;      返回调用该函数的对象
其中，return语句解引用this指针以获得该函数的对象，换句话说，上面的这个调用
返回total的引用。
*** 7.1.3 定义类相关的非成员函数
一般来说，如果非成员函数是类的接口的组成部分，则这些函数的声明应该与类
在同一个头文件中
**** 定义read和print函数
     
